/*! For license information please see 816.13a1d39a.chunk.js.LICENSE.txt */
(("undefined"!==typeof self?self:this).webpackChunkreact_cli=("undefined"!==typeof self?self:this).webpackChunkreact_cli||[]).push([[816],{5816:function(e,r,n){"use strict";n.r(r),n.d(r,{default:function(){return s}});var t=n(2137),u=n(7757),a=n.n(u),i=n(7313),c={vertex:n(9170),fragment:n(943)},o=n(6947),s=(n(8466),function(){var e=(0,i.useRef)(null),r=(0,i.useRef)(null),n=(0,i.useRef)(null),u=(0,i.useRef)(null),s=(0,i.useRef)(null),f=(0,i.useRef)(0),v=(0,i.useRef)(null),l=function(r){if(e.current){var n=v.current.material.uniforms,t=r.clientX,u=r.clientY;n.mouse_xy.value=new o.FM8(t/e.current.clientWidth,1-u/e.current.clientHeight)}},m=function(r){if(e.current)for(var n=v.current.material.uniforms,t=r.clientX,u=r.clientY,a=0;a<4;a+=1)if(-1===n.progress.value[a]){n.progress.value[a]=0,n.centres.value[a]=new o.FM8(t/e.current.clientWidth,1-u/e.current.clientHeight);break}},d=(0,i.useCallback)((function(){var e=v.current.material.uniforms,t=performance.now()-f.current;f.current=performance.now(),e.u_time.value=Math.abs(f.current);for(var a=0;a<4;a+=1){var i=e.progress.value[a];i>=1?e.progress.value[a]=-1:i>=0&&(e.progress.value[a]+=t/2e3)}r.current.render(u.current,n.current),requestAnimationFrame(d)}),[]);return(0,i.useEffect)((function(){(0,t.Z)(a().mark((function t(){var i,p,_,w,g,x;return a().wrap((function(t){for(;;)switch(t.prev=t.next){case 0:if(!e.current){t.next=27;break}return r.current=new o.CP7({canvas:e.current,antialias:!0}),r.current.setSize(window.innerWidth,window.innerHeight),u.current=new o.xsS,n.current=new o.iKG(-8,8,4.5,-4.5,.1,100),n.current.position.set(0,0,1),n.current.lookAt(new o.Pa4(0,0,0)),u.current.add(n.current),i=new o.Mig("red"),u.current.add(i),s.current=new o.dpR,p=new o._12(16,9),t.next=14,new Promise((function(e,r){s.current.load("/mount.jpg",(function(r){e(r)}),void 0,(function(e){r(e)}))}));case 14:return _=t.sent,t.next=17,new Promise((function(e,r){s.current.load("/three-shader/mount-map.jpg",(function(r){e(r)}),void 0,(function(e){r(e)}))}));case 17:w=t.sent,g={image:{type:"t",value:_},image_beifen:{type:"t",value:w},aspect:{type:"f",value:16/9},radius:{type:"f",value:.2},amp:{type:"f",value:.9},band:{type:"f",value:.3},waves:{type:"f",value:5},speed:{type:"f",value:7},u_time:{type:"f",value:f.current},mouse_xy:{type:"v2v",value:new o.FM8(0,0)},progress:{type:"fv",value:[-1,-1,-1,-1]},centres:{type:"v2v",value:[new o.FM8(0,0),new o.FM8(0,0),new o.FM8(0,0),new o.FM8(0,0)]}},(x=new o.jyz({uniforms:g,vertexShader:c.vertex.default,fragmentShader:c.fragment.default})).needsUpdate=!0,v.current=new o.Kj0(p,x),u.current.add(v.current),e.current.addEventListener("click",m),e.current.addEventListener("mousemove",l),d();case 27:case"end":return t.stop()}}),t)})))()}),[d]),i.createElement("div",{className:"test___2bz8d"},i.createElement("canvas",{ref:e}))})},943:function(e,r,n){"use strict";n.r(r),r.default="const int numbers = 4;\r\n\r\nuniform sampler2D image;\r\nuniform sampler2D image_beifen;\r\nuniform float aspect;\r\nuniform float radius;\r\nuniform float amp;\r\nuniform float band;\r\nuniform float waves;\r\nuniform float speed;\r\nuniform float u_time;\r\nuniform float progress[numbers];\r\nuniform vec2 centres[numbers];\r\nuniform vec2 mouse_xy;\r\n\r\nvarying vec2 vUv;\r\n\r\nvec2 mirrored(vec2 v) {\r\n  vec2 m = mod(v,2.);\r\n  return mix(m,2.0 - m, step(1.0 ,m));\r\n}\r\n\r\n\r\n\r\n\r\n\r\nvoid main() {\r\n  vec2 tc = vUv.xy;\r\n  vec2 uv = vec2(0.0, 0.0);\r\n  vec2 p;\r\n  float len;\r\n  vec2 uv_offset;\r\n  float wave_width = band * radius;\r\n\r\n  for (int i = 0; i < numbers; i += 1) {\r\n    if (progress[i] == -1.0) {\r\n      continue;\r\n    }\r\n\r\n    p = (tc - centres[i]);\r\n    p.x = p.x * aspect;\r\n    len = length(p);\r\n\r\n    float current_progress = progress[i];\r\n    float current_radius = radius * current_progress;\r\n    float damp_factor = 1.0;\r\n    if (current_progress > .5) {\r\n      damp_factor = (1.0 - current_progress) * 2.0;\r\n    }\r\n\r\n    float cut_factor = clamp(wave_width * damp_factor - abs(current_radius - len), 0.0, 1.0);\r\n    float waves_factor = waves * len / radius;\r\n    uv_offset = (p / len) * cos((waves_factor - current_progress * speed) * 3.14) * amp * cut_factor;\r\n\r\n    uv += uv_offset;\r\n  \r\n  }\r\n  vec2 now_xy = tc + uv;\r\n\r\n  if(uv!=vec2(0.0,0.0)){\r\n    vec4 depth = texture2D(image_beifen, now_xy);\r\n    vec2 fake3d = vec2(now_xy.x + (depth.g - 0.5)*mouse_xy.x/35.0, now_xy.y + (depth.r - 0.5)*mouse_xy.y/15.0);\r\n\r\n    vec4 t_image = texture2D(image, mirrored(fake3d));\r\n    gl_FragColor = t_image;\r\n  } else {\r\n      vec4 depth = texture2D(image_beifen, now_xy);\r\n\r\n      vec2 fake3d = vec2(now_xy.x + (depth.g - 0.5)*mouse_xy.x/35.0, now_xy.y + (depth.r - 0.5)*mouse_xy.y/15.0);\r\n\r\n      vec4 t_image = texture2D(image, mirrored(fake3d));\r\n      gl_FragColor = t_image;\r\n  }\r\n\r\n}\r\n\r\n\r\n\r\n"},9170:function(e,r,n){"use strict";n.r(r),r.default="varying vec2 vUv;\r\n\r\nvoid main() {\r\n\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\r\n\r\n\tvUv = uv;\r\n\t\r\n\tvec3 pos = position;\r\n\r\n\r\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);\r\n}\r\n"}}]);